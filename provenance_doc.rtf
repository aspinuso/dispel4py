{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 dispel4py\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 ProvenanceType\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A workflow is a program that combines atomic and independent processing elements via a specification language and a library of components. More advanced systems adopt abstractions to facilitate re-use of workflows across users' contexts and application domains. While methods can be multi-disciplinary, provenance should be meaningful to the domain adopting them. Therefore, a portable specification of a workflow requires mechanisms allowing the contextualisation of the provenance produced. For instance, users may want to extract domain-metadata from a component or groups of components adopting vocabularies that match their domain and current research, tuning the level of granularity. To allow this level of flexibility, we explore an approach that considers a workflow component described by a class, according to the Object-Oriented paradigm. The class defines the behaviour of its instances as their type, which specifies what an instance will do in terms of a set of methods. We introduce the concept of {\i ProvenanceType}, that augments the basic behaviour by extending the class native type, so that a subset of those methods perform the additional actions needed to deliver provenance data. Some of these are being used by some of the preexisting methods, and characterise the behaviour of the specific provenance type, some others can be used by the developer to easily control precision and granularity. This approach, tries to balance between automation, transparency and explicit intervention of the developer of a data-intensive tool, who can tune provenance-awareness through easy-to-use extensions.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The type-based approach to provenance collection provides a generic {\i ProvenanceType} class that defines the properties of a provenance-aware workflow component. It provides a wrapper that meets the provenance requirements, while leaving the computational behaviour of the component unchanged. Types may be developed as {\b Pattern Type} and {\b Contextual Type} to represent respectively complex computational patterns and to capture specific metadata contextualisations associated to the produce output data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\i ProvenanceType} presents the following class constants to indicate where the lineage information will be stored. Options include a remote repository, a local file system or a {\i ProvenanceSensor} (experimental).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i SAVE}MODE_SERVICE='service'_\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i SAVE}MODE_FILE='file'_\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i SAVE}MODE_SENSOR='sensor'_\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The following variables will be used to configure some general provenance capturing properties\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i PROV}PATH_: When {\i SAVE}MODE_SERVICE_ is chosen, this variable should be populated with a string indcating a file system path wher the lineage will be stored\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i REPOS}URL_: When {\i SAVE}MODE_SERVICE_ is chosen, this variable should be populated with a string indcating the repository endpoint (S-ProvFlow) where the provenance will be sent.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i PROV}DATA_EXPORT_URL: The service endpoint from where the provenance of a workflow execution, after being stored, can be extracted in PROV format.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i BULK}SIZE_: Number of lineage documents to be stored in a single file or in a single request to the remote service. Helps tuning the overhead brough by the latency of accessing storage resources.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 getProvStateObjectId\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.getProvStateObjectId(self, name)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Check if a data object with lookupterm {\i name}, is part of the provenance state ({\i s-prov:StateCollection}) and returns its {\i id}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 makeProcessId\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.makeProcessId(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Return the {\i id} to be attributed to an running instance ({\i s-prov:ComponentInstance}) of a processing element.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 makeUniqueId\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.makeUniqueId(self, data, output_port)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\b Contextualisation type}. Return the {\i id} to be attributed to a data entity ({\i s-prov:Data}) produced in output.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 apply_derivation_rule\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.apply_derivation_rule(self, event, voidInvocation, oport=None, iport=None, data=None, metadata=None)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\i Pattern type}. This method is invoked by the {\i ProvenanceType} each iteration when a decision has to be made whether to ignore or discard the dependencies on the ingested stream and stateful entities, applying a specific provenance pattern, thereby creating input/output derivations. The framework invokes this method every time the data is written on an output port ({\i event}: {\i write}) and every time an invocation ({\i s-prov:Invocation}) ends ({\i event}: {\i end}invocation_event_). The latter can be further described by the boolean parameter {\i voidInvocation}, indicating whether the invocation terminated with any data produced. The default implementation provides a {\i stateless} behaviour, where the output depends only from the input data recieved during the invocation.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 getInputAt\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.getInputAt(self, port='input', gindex=None)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Return input data currently available at a specific {\i port}. When reading input of a grouped operator, the {\i gindex} parameter allows to access exclusively the data related to the group index.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 addNamespacePrefix\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.addNamespacePrefix(self, prefix, url)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\i Contextualisation type}. A Namespace {\i prefix} can be declared with its vocabulary {\i url} to map the metadata terms to external controlled vocabularies. They can be used to qualify the metadata terms extracted from the {\i extractItemMetadata} function, as well as for those terms injected selectively at runtime by the {\i write} method. The namespaces will be used consistently when exporting the lineage traces to semantic-web formats, such as RDF.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 extractItemMetadata\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.extractItemMetadata(self, data, port)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\i Contextualisation type}. Extracts metadata from the domain specific content of the data (s-prov:DataGranules) written on a components output {\i port}, according to a particular vocabulary.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ignorePastFlow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.ignorePastFlow(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\b Pattern type}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It instructs the type to ignore the all the inputs when the method {\i apply}derivation_rule_ is invoked for a certain event."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 ignoreState\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.ignoreState(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\b Pattern type}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It instructs the type to ignore the content of the provenance state when the method {\i apply}derivation_rule_ is invoked for a certain event."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 discardState\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.discardState(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\b Pattern type}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It instructs the type to reset the data dependencies in the provenance state when the method {\i apply}derivation_rule_ is invoked for a certain event. These will not be availabe in the following invocations."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 discardInFlow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.discardInFlow(self, wlength=None, discardState=False)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\b Pattern type}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It instructs the type to reset the data dependencies related to the component''s inputs when the method {\i apply}derivation_rule_ is invoked for a certain event. These will not be availabe in the following invocations."\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 update_prov_state\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.update_prov_state(self, lookupterm, data, location='', format='', metadata=\{\}, ignore_inputs=False, ignore_state=True, **kwargs)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\i Pattern type} or inn those circumstances where developers require to explicitly manage the provenance information within the component''s logic,.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Updates the provenance state ({\i s-prov:StateCollection}) with a reference, identified by a {\i lookupterm}, to a new {\i data} entity or to the current input. The {\i lookupterm} will allow developers to refer to the entity when this is used to derive new data. Developers can specify additional {\i medatata} by passing a metadata dictionary. This will enrich the one generated by the {\i extractItemMetadata} method. Optionally the can also specify {\i format} and {\i location} of the output when this is a concrete resource (file, db entry, online url), as well as instructing the provenance generation to 'ignore_input' and 'ignore_state' dependencies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\i kwargs} parameter allows to pass an argument {\i dep} where developers can specify a list of data {\i id} to explicitly declare dependencies with any data in the provenance state ({\i s-prov:StateCollection}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 write\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.write(self, name, data, **kwargs)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is the native write operation of dispel4py triggering the transfer of data between adjacent components of a workflow. It is extended by the {\i ProvenanceType} with explicit provenance controls through the {\i kwargs} parameter. We assume these to be ignored when provenance is deactivated. Also this method can use the lookup tags to establish dependencies of output data on entities in the provenance state.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\i kwargs} parameter allows to pass the following arguments: - {\i dep} : developers can specify a list of data {\i id} to explicitly declare dependencies with any data in the provenance state ({\i s-prov:StateCollection}). - {\i metadata}: developers can specify additional medatata by passing a metadata dictionary. - {\i ignore}inputs_: instructs the provenance generation to ignore the dependencies on the current inputs. - {\i format}: the format of the output. - {\i location}: location of the output when this is a concrete resource (file, db entry, online url).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 checkSelectiveRule\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.checkSelectiveRule(self, streammeta)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In alignement with what was previously specified in the configure_prov_run for the Processing Element, check the data granule metadata whether its properies values fall in a selective provenance generation rule.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 checkTransferRule\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.checkTransferRule(self, streammeta)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In alignement with what was previously specified in the configure_prov_run for the Processing Element, check the data granule metadata whether its properies values fall in a selective data transfer rule.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 extractDataSourceId\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceType.extractDataSourceId(self, data, port)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In support of the implementation of a {\i ProvenanceType} realising a lineage {\i Pattern type}. Extract the id from the incoming data, if applicable, to reuse it to identify the correspondent provenance entity. This functionality is handy especially when a workflow component ingests data represented by self-contained and structured file formats. For instance, the NetCDF attributes Convention includes in its internal metadata an id that can be reused to ensure the linkage and therefore the consistent continuation of provenance tracesbetween workflow executions that generate and use the same data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 AccumulateFlow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 AccumulateFlow(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for a Processing Element ({\i s-prov:Component}) whose output depends on a sequence of input data; e.g. computation of periodic average.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Nby1Flow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 Nby1Flow(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for a Processing Element ({\i s-prov:Component}) whose output depends on the data received on all its input ports in lock-step; e.g. combined analysis of multiple variables.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 SlideFlow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SlideFlow(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for a Processing Element ({\i s-prov:Component}) whose output depends on computations over sliding windows; e.g. computation of rolling sums.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 ASTGrouped\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ASTGrouped(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for a Processing Element ({\i s-prov:Component}) that manages a stateful operator with grouping rules; e.g. a component that produces a correlation matrix with the incoming coefficients associated with the same sampling-iteration index\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 SingleInvocationFlow\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 SingleInvocationFlow(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for a Processing Element ({\i s-prov:Component}) that presents stateless input output dependencies; e.g. the Processing Element of a simple I/O pipeline.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 AccumulateStateTrace\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 AccumulateStateTrace(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for a Processing Element ({\i s-prov:Component}) that keeps track of the updates on intermediate results written to the output after a sequence of inputs; e.g. traceable approximation of frequency counts or of periodic averages.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 IntermediateStatefulOut\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 IntermediateStatefulOut(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for a Processing Element ({\i s-prov:Component}) stateful component which produces distinct but interdependent output; e.g. detection of events over periodic observations or any component that reuses the data just written to generate a new product\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 ForceStateless\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ForceStateless(self)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for a Processing Element ({\i s-prov:Component}). It considers the outputs of the component dependent only on the current input data, regardless from any explicit state update; e.g. the user wants to reduce the amount of lineage produced by a component that presents inline calls to the {\i update}prov_state_, accepting less accuracy.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 get_source\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 get_source(object, spacing=10, collapse=1)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Print methods and doc strings.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Takes module, class, list, dictionary, or string. ## configure_prov_run\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 configure_prov_run(graph, provRecorderClass=None, provImpClass=<class 'dispel4py.provenance_doc.ProvenanceType'>, input=None, username=None, workflowId=None, description=None, system_id=None, workflowName=None, workflowType=None, w3c_prov=False, runId=None, componentsType=None, clustersRecorders=\{\}, feedbackPEs=[], save_mode='file', sel_rules=\{\}, transfer_rules=\{\}, update=False)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To enable the user of a data-intensive application to configure the attribution of types, selectivity controls and activation of advanced exploitation mechanisms, we introduce the concept of provenance configuration. With the configuration users can specify a number of properties, such as attribution, provenance types, clusters, sensors, selectivity rules, etc. The configuration is used at the time of the initialisation of the workflow to prepare its provenance-aware execution. We consider that a chosen configuration may be influenced by personal and community preferences, as well as by rules introduced by institutional policies. For instance, a Research Infrastructure (RI) may indicate best practices to reproduce and describe the operations performed by the users exploiting its facilities, or even impose requirements which may turn into quality assessment metrics. This could require to choose among a set of contextualisation types, in order to adhere to the infrastructure's metadata portfolio. Thus, a provenance configuration profile play in favour of more generality, encouraging the implementation and the re-use of fundamental methods across disciplines.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With this method, the users of the workflow provide general provenance information on the attribution of the run, such as {\i username}, {\i runId} (execution id), {\i description}, {\i workflowName}, and its semantic characterisation {\i workflowType}. It allows users to indicate which provenance types to apply to each component and the belonging conceptual provenance cluster. Moreover, users can also choose where to store the lineage ({\i save}mode_), locally in the file system or in a remote service or database. Lineage storage operations can be performed in bulk, with different impacts on the overall overhead and on the experienced rapidity of access to the lineage information.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b Selectivity and Transfer rules}: By declaratively indicating a set of Selectivity and Transfer rules for every component ({\i sel}rules_, {\i transfer}rules_), users can respectively activate the collection of the provenance for particular Data elements or trigger transfer operations of the data to external locations. The approach takes advantage of the contextualisation possibilities offered by the provenance {\i Contextualisation types}. The rules consist of comparison expressions formulated in JSON that indicate the boundary values for a specific metadata term. Such representation is inspired by the query language and selectors adopted by a popular document store, MongoDB.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Example, a Processing Element {\i CorrCoef} that produces lineage information only when the {\i rho} value is greater than 0:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1     \{ "CorrCoef": \{\line
        "rules": \{\line
            "rho": \{\line
                "$gt": 0\line
    \}\}\}\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 ProvenanceSimpleFunctionPE\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceSimpleFunctionPE(self, *args, **kwargs)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for the native {\i SimpleFunctionPE} of dispel4py\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 ProvenanceIterativePE\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 ProvenanceIterativePE(self, *args, **kwargs)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\i Pattern type} for the native {\i IterativePE} Element of dispel4py\par}
